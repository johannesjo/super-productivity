#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const dotenv = require('dotenv');

// Load .env file
const envPath = path.join(process.cwd(), '.env');
const envConfig = dotenv.config({ path: envPath });

let env = envConfig.parsed || {};

// In CI environment, also read from process.env for specific keys
if (process.env.CI === 'true' || !envConfig.parsed) {
  console.log('ðŸ” CI environment detected, checking for environment variables...');

  // List of environment variables to check for in CI
  const ciEnvKeys = [
    'UNSPLASH_KEY',
    'UNSPLASH_CLIENT_ID',
    'GOOGLE_DRIVE_TOKEN',
    'DROPBOX_API_KEY',
    'WEBDAV_URL',
    'WEBDAV_USERNAME',
    'WEBDAV_PASSWORD',
  ];

  ciEnvKeys.forEach((key) => {
    if (process.env[key]) {
      env[key] = process.env[key];
      console.log(`  âœ“ Found ${key} in environment`);
    }
  });
}

if (Object.keys(env).length === 0) {
  console.warn('âš ï¸  No environment variables found, generating empty env.generated.ts');
}

// Generate TypeScript content
const tsContent = `// This file is auto-generated by tools/load-env.js
// Do not modify directly - edit .env file instead
// Generated at: ${new Date().toISOString()}

/**
 * Environment variables loaded from .env file
 * Access these constants instead of process.env in your Angular app
 */
export const ENV = {
${Object.entries(env)
  .map(([key, value]) => {
    // Escape quotes in values
    const escapedValue = value.replace(/'/g, "\\'");
    return `  ${key}: '${escapedValue}',`;
  })
  .join('\n')}
} as const;

// Type-safe helper to ensure all expected env vars are defined
export type EnvVars = typeof ENV;
`;

// Ensure the config directory exists
const configDir = path.join(process.cwd(), 'src/app/config');
if (!fs.existsSync(configDir)) {
  fs.mkdirSync(configDir, { recursive: true });
}

// Write the generated file
const outputPath = path.join(configDir, 'env.generated.ts');
fs.writeFileSync(outputPath, tsContent);

console.log(
  `âœ… Generated ${outputPath} with ${Object.keys(env).length} environment variables`,
);

// Pass through to the next command
if (process.argv.length > 2) {
  // Execute the rest of the command
  const { spawn } = require('child_process');
  const command = process.argv[2];
  const args = process.argv.slice(3);

  const child = spawn(command, args, {
    stdio: 'inherit',
    shell: true,
  });

  child.on('exit', (code) => {
    process.exit(code);
  });
}
