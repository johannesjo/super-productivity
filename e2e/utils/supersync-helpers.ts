import { type Browser, type BrowserContext, type Page } from '@playwright/test';
import { SuperSyncPage, type SuperSyncConfig } from '../pages/supersync.page';
import { WorkViewPage } from '../pages/work-view.page';
import { waitForAppReady } from './waits';

/**
 * SuperSync server URL for E2E tests.
 * Server must be running with TEST_MODE=true.
 * Defaults to port 1901 for e2e tests (dev server uses 1900).
 */
export const SUPERSYNC_BASE_URL =
  process.env.SUPERSYNC_E2E_URL || 'http://localhost:1901';

/**
 * Test user credentials returned from the server.
 */
export interface TestUser {
  email: string;
  token: string;
  userId: number;
}

/**
 * A simulated client for E2E sync tests.
 * Wraps a browser context, page, and page objects.
 */
export interface SimulatedE2EClient {
  context: BrowserContext;
  page: Page;
  workView: WorkViewPage;
  sync: SuperSyncPage;
  clientName: string;
}

/**
 * Create a test user on the SuperSync server.
 * Requires server to be running with TEST_MODE=true.
 *
 * @param testId - Unique test identifier for user email
 * @returns Test user with email and JWT token
 */
export const createTestUser = async (
  testId: string,
  maxRetries = 3,
): Promise<TestUser> => {
  const email = `test-${testId}@e2e.local`;
  const password = 'TestPassword123!';

  const headers = new Headers();
  headers.set('Content-Type', 'application/json');

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    const response = await fetch(`${SUPERSYNC_BASE_URL}/api/test/create-user`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ email, password }),
    });

    // Handle rate limiting with exponential backoff
    if (response.status === 429 && attempt < maxRetries - 1) {
      const delay = 1000 * Math.pow(2, attempt);
      console.log(`[createTestUser] Rate limited (429), retrying in ${delay}ms...`);
      await new Promise((r) => setTimeout(r, delay));
      continue;
    }

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Failed to create test user: ${response.status} - ${text}`);
    }

    const data = await response.json();
    return {
      email,
      token: data.token,
      userId: data.userId,
    };
  }

  throw new Error(`Max retries (${maxRetries}) exceeded for createTestUser`);
};

/**
 * Clean up all test data on the server.
 * Call this in test teardown if needed.
 */
export const cleanupTestData = async (): Promise<void> => {
  const response = await fetch(`${SUPERSYNC_BASE_URL}/api/test/cleanup`, {
    method: 'POST',
  });

  if (!response.ok) {
    console.warn(`Cleanup failed: ${response.status}`);
  }
};

/**
 * Check if the SuperSync server is running, healthy, AND has test mode enabled.
 * Tests require TEST_MODE=true on the server for the /api/test/* endpoints.
 */
export const isServerHealthy = async (): Promise<boolean> => {
  try {
    // First check basic health
    const healthResponse = await fetch(`${SUPERSYNC_BASE_URL}/health`, {
      method: 'GET',
      signal: AbortSignal.timeout(2000),
    });
    if (!healthResponse.ok) {
      return false;
    }

    // Then verify test mode is enabled by trying to create a dummy user
    // This is the only reliable way to check if test endpoints exist
    const headers = new Headers();
    headers.set('Content-Type', 'application/json');
    const testModeResponse = await fetch(`${SUPERSYNC_BASE_URL}/api/test/create-user`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        email: `health-check-${Date.now()}@test.local`,
        password: 'HealthCheck123!',
      }),
      signal: AbortSignal.timeout(3000),
    });

    // If test mode is disabled, the route won't exist (404)
    // If test mode is enabled, we'll get 201 (created) or 409 (conflict) or similar
    if (testModeResponse.status === 404) {
      console.warn('SuperSync server is running but TEST_MODE is not enabled');
      return false;
    }

    return true;
  } catch {
    return false;
  }
};

/**
 * Get SuperSync configuration for a test user.
 */
export const getSuperSyncConfig = (user: TestUser): SuperSyncConfig => {
  return {
    baseUrl: SUPERSYNC_BASE_URL,
    accessToken: user.token,
  };
};

/**
 * Create a simulated E2E client with its own isolated browser context.
 *
 * Each client has:
 * - Separate browser context (isolated IndexedDB, localStorage)
 * - Unique clientId generated by the app on first load
 * - WorkViewPage for task operations
 * - SuperSyncPage for sync operations
 *
 * @param browser - Playwright browser instance
 * @param baseURL - App base URL (e.g., http://localhost:4242)
 * @param clientName - Human-readable name for debugging (e.g., "A", "B")
 * @param testPrefix - Test prefix for task naming
 */
export const createSimulatedClient = async (
  browser: Browser,
  baseURL: string,
  clientName: string,
  testPrefix: string,
): Promise<SimulatedE2EClient> => {
  // Use provided baseURL or fall back to localhost:4242 (Playwright fixture may be undefined)
  const effectiveBaseURL = baseURL || 'http://localhost:4242';

  const context = await browser.newContext({
    storageState: undefined, // Clean slate - no shared state
    userAgent: `PLAYWRIGHT SYNC-CLIENT-${clientName}`,
    baseURL: effectiveBaseURL,
    viewport: { width: 1920, height: 1080 },
  });

  const page = await context.newPage();

  // Set up error logging
  page.on('pageerror', (error) => {
    console.error(`[Client ${clientName}] Page error:`, error.message);
  });

  page.on('console', (msg) => {
    if (msg.type() === 'error') {
      console.error(`[Client ${clientName}] Console error:`, msg.text());
    } else if (process.env.E2E_VERBOSE) {
      console.log(`[Client ${clientName}] Console ${msg.type()}:`, msg.text());
    }
  });

  // Navigate to app and wait for ready
  await page.goto('/');
  await waitForAppReady(page);

  const workView = new WorkViewPage(page, `${clientName}-${testPrefix}`);
  const sync = new SuperSyncPage(page);

  return {
    context,
    page,
    workView,
    sync,
    clientName,
  };
};

/**
 * Close a simulated client and clean up resources.
 */
export const closeClient = async (client: SimulatedE2EClient): Promise<void> => {
  await client.context.close();
};

/**
 * Wait for a task with given name to appear on the page.
 * Uses longer timeout by default for sync operations which can be slow.
 * Includes retry logic for better reliability after sync operations.
 */
export const waitForTask = async (
  page: Page,
  taskName: string,
  timeout = 60000,
): Promise<void> => {
  const escapedName = taskName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const startTime = Date.now();

  // Retry loop to handle DOM update delays
  while (Date.now() - startTime < timeout) {
    try {
      await page.waitForSelector(`task:has-text("${escapedName}")`, {
        timeout: 5000,
        state: 'visible',
      });
      return; // Success
    } catch {
      // Wait a bit and retry
      await page.waitForTimeout(300);
    }
  }

  // Final attempt with full remaining timeout
  const remaining = Math.max(timeout - (Date.now() - startTime), 1000);
  await page.waitForSelector(`task:has-text("${escapedName}")`, {
    timeout: remaining,
    state: 'visible',
  });
};

/**
 * Count tasks matching a pattern on the page.
 */
export const countTasks = async (page: Page, pattern?: string): Promise<number> => {
  if (pattern) {
    const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return page.locator(`task:has-text("${escapedPattern}")`).count();
  }
  return page.locator('task').count();
};

/**
 * Check if a task exists on the page.
 */
export const hasTask = async (page: Page, taskName: string): Promise<boolean> => {
  const escapedName = taskName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const count = await page.locator(`task:has-text("${escapedName}")`).count();
  return count > 0;
};
